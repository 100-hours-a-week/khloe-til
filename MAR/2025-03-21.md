# TIL Template

## 날짜: 2025-03-21



### [새로 배운 내용]
## 주제 : 💾 데이터베이스 딥다이브

## ERD(Entity-Relationship Diagram)가 데이터베이스 설계의 효율성을 높이는 이유를 설명하시오.
### ✨ ERD(Entity-Relationship Diagram)

 **: Entity 개체'와 'Relationship 관계'를 중점적으로 표시하는 데이터베이스 구조를 한 눈에(시각적으로) 표현한 다이어그램 입니다.  어떻게 조직되고 상호작용되는지 이해하는 데 도움이 됩니다.**

데이터베이스는 시스템의 핵심이며, 잘못 설계된 데이터베이스는 성능 저하, 중복 데이터, 데이터 무결성 문제 등 다양한 문제를 초래할 수 있습니다.따라서, 설계 초기 단계에서 ERD를 통해 문제점을 미리 파악하고 수정하는 것이 중요합니다.

ERD설계는 데이터베이스의 **효율성**과 **무결성**을 결정짓는 중요한 단계입니다. 올바른 ERD 설계를 통해 **시스템의 성능과 유지보수성을 향상**시킬 수 있으므로, ERD 설계 단계에 충분한 시간과 노력을 투자하는 것이 중요합니다.,

### ERD 설계 시 고려할 주요 사항

1. **엔터티(Entity) 관련 질문**:
    - 시스템에서 중요한 데이터 객체나 개념은 무엇인가요?
    - 각 엔터티의 주요 속성은 무엇인가요?
    - 각 엔터티의 기본 키는 무엇인가요?
2. **관계(Relationship) 관련 질문**:
    - 어떤 엔터티들이 서로 관계를 가지고 있나요?
    - 해당 관계의 카디널리티(예: 일대일, 일대다, 다대다)는 무엇인가요?
    - 관계에는 어떤 속성이 포함되어 있나요?
3. **제약 조건**:
    - 어떤 엔터티나 속성에 특별한 제약 조건이 존재하나요? (예: Not Null, Unique 등)
    - 어떤 엔터티의 데이터가 다른 엔터티의 데이터에 의존성을 가지나요?
4. **엔터티의 수명주기**:
    - 어떤 엔터티가 생성되고, 언제 수정되며, 언제 삭제되나요?
    - 엔터티의 수명주기 동안 어떤 이벤트나 조건이 적용되나요?
5. **정규화**:
    - 데이터 중복을 피하기 위해 어떻게 데이터베이스를 정규화 할 수 있나요?
    - 현재 설계에서 발생할 수 있는 이상현상은 무엇인가요?
6. **성능 및 확장성**:
    - 가장 자주 접근되거나 수정될 엔터티는 무엇인가요?
    - 대용량의 데이터나 높은 트랜잭션을 처리해야 하는 부분은 어디인가요?
7. **보안**:
    - 어떤 데이터가 민감하며 특별한 보안 조치가 필요한가요?
    - 어떤 사용자나 시스템이 각 엔터티나 관계에 대한 접근 권한을 가져야 하나요?

### ✅ 결론

데이터 구조를 한 눈에 파악할 수 있으며 사전에 설계 오류를 발견할 가능성이 높고, 협업뿐만 아니라 시스템 성능과 유지보수성 향상에 큰 영향을 줍니다.

---

**🔨ER 다이어그램 툴 참고:**

* [lucidchart](https://www.lucidchart.com/pages)

* [diagrams.net](https://app.diagrams.net/)

# 데이터베이스 성능 최적화를 위한 확장 및 캐싱 전략

**데이터베이스 성능 최적화(Database Performance Optimization):** 데이터베이스 시스템의 응답 시간, 처리량, 자원 사용 효율성을 향상시키기 위한 다양한 기법과 전략을 사용하는 과정입니다.

## 📌 확장

확장성을 고려한 데이터베이스 설계는 시스템의 장기적인 성공에 필수적입니다. 초기 설계 단계에서 확장성을 고려하지 않으면 나중에 큰 비용이 발생할 수 있습니다.

### 1. 수직적 확장(Scale up)

데이터베이스 서버의 **하드웨어 성능**을 개선하여 처리 능력을 높이는 방법입니다. CPU, 메모리, 디스크 성능을 향상시켜 성능을 증대시킬 수 있습니다. 이 방법은 구현이 간단하고 기존 시스템을 유지할 수 있지만, 비용이 많이 들고 확장 한계(물리적 공간, 잔여 슬롯, HW간의 호환성) 그리고 다운타임 문제가 있습니다.

중요한 것은 이런 경우 보통 단일 서버로 서비스를 운영하기 때문에 하나의 서버로 부하가 집중되어, 시스템에서 문제가 발생하면 모든 시스템을 사용할 수 없는 문제(단일 장애점이)가 생깁니다. 

따라서 일반적으로 수직 확장은 데이터 일관성, 무결성이 중요한 데이터베이스 서버에 적합합니다.

### 2. 수평적 확장(Scale out)

여러 대의 데이터베이스 **서버를 추가**하여 부하를 분산시키는 방법입니다. 데이터와 트래픽을 여러 서버에 분산시켜 성능을 높일 수 있습니다. **확장성이 뛰어나고 비용적 측면에서도 효율적**이지만, 시스템 복잡도가 증가하고 데이터 일관성(분산된 데이터 동기화)을 유지하기 어려울 수 있습니다. 또한, 수직 확장과 다르게 여러 서버를 한 서버처럼 사용하기 위한 클러스터링 작업에 추가 비용이 발생하고, 로드밸런싱이 필수적으로 동반되어야합니다. 이처럼 수평적 확장은 기술적으로나 관리적으로 수직적 확장에 비해 까다롭고 어렵습니다. 하지만, 단일 장애점을 갖지 않으므로 **장애에 치명적이지 않고** 이론적으로 확장에 제한이 없어 무한 확장 가능합니다.

따라서 오늘날의 서비스들은 특정 시간대, 기간에만 유저 수요가 급격히 증가할 수 있는 특성이 있기 때문에 대부분의 웹(앱) 서비스 서버는 **유연한 수평적 확장**을 사용합니다. 


1. 샤딩(Sharding) :여러 개의 작은 데이터베이스(일반적으로 NoSQL)로 분할하여 분산 저장하는 방법입니다.
    
    샤드는 독립적으로 운영되며, 특정 데이터 집합을 처리합니다. 하지만 재샤딩, 조인과 비정규화 등 따라오는 문제도 존재합니다.
    
    종류로는 범위 기준으로 분할하는 범위 샤딩(e.g: 날짜, 알파벳 순서…), 해시 함수에 따라 데이터를 균등하게 분배하는 해시 샤딩, 지역 별로 데이터를 저장하고 처리하여 지연 시간을 줄이는 지리적 샤딩이 있습니다.
    
2. 파티셔닝(Partitioning)
    
    데이터의 논리적 분할에 따른 분산 처리 및 저장을 수행할 수 있습니다. 
    
    수직 파티셔닝은 column을 분할하여 여러 개의 다른 테이블로 나누는 방법이며, 성능 개선 이외에도 이미 정규화가 되어있는 테이블을 퍼포먼스를 위해, 자주 사용되지 않는 column을 모아놓거나 민감한 정보에 저한을 걸어 접근을 방지하는 등의 용도로 사용됩니다. 반면에 수평 파티셔닝은 Row를 분할하여 여러 개의 다른 테이블로 나누는 방법이며, DB용량이 커지면서 성능 저하를 막기 위해 사용됩니다.
    

⊕ 클라우드 기반 데이터베이스는 자동 수직, 수평적 확장을 구현할 수 있습니다.

## 📌 캐싱

본래 데이터베이스는 I/O 기반으로 디스크를 접근하기때문에 상대적으로 느립니다. 때문에 같은 쿼리(유저 정보, 인기글 조회 등)를 반복해서 요청하게 되면 트래픽이 증가하여 부하가 발생되어 이는 응답 지연, 서버 다운까지 이어지게 됩니다. 

이러한 이유로 “Cache”를 도입하여 데이터를 메모리에 저장하여 필요할 때마다 디스크에 직접 접근하지 않고 메모리로 접근하여 성능이 향상되는 효과를 얻을 수 있습니다.

캐싱은 자주 사용되는 데이터를 메모리에 저장하여 데이터베이스 조회를 최소화하여 부하를 줄이고 응답 속도를 향상시키는 최적화 기법 중 하나입니다. (웹 서비스의 캐시 기능과 동일)

원본 데이터 접근보다 빠르고, 같은 데이터를 반복적으로 접근하는 상황에서 사용하기 알맞습니다. 또한, 인증 세션 값과 같이 잘 변하지 않는 데이터일수록, 조인과 서브쿼리가 많은 복잡한 쿼리, 집계쿼리일수록  효율적입니다.

| 종류 | 설명 | 예시 |
| --- | --- | --- |
| Read-Through | 데이터 요청 시 캐시에 없으면 DB에서 읽고, 캐시에 저장 | 사용자 정보, 상품 정보 |
| Write-Through | 데이터를 저장할 때 DB + 캐시에 동시에 기록 | 로그인 횟수, 설정값 |
| Write-Behind / Write-Back | 캐시에 먼저 저장 → 일정 시간 후 비동기적으로 DB 반영 | 실시간 랭킹 등 |
| Cache-Aside (Lazy Loading) | 코드에서 직접 캐시 조회 & 없으면 DB 조회 후 캐시에 저장 | 거의 대부분의 API에 적합 |
| TTL(Time To Live) | 일정 시간 후 캐시 자동 삭제 | 뉴스 목록 5분 캐싱 등 |

캐싱 도구 : Redis, Memcached, Local Cache 등이 있습니다.

### ⚠️ 캐싱 주의사항

데이터가 변경됐는데, 캐시는 이전 값이라면 → 캐시 무효화 필요

해결: TTL을 짧게 설정, 데이터 변경 시 직접 캐시 삭제

TTL이 만료된 순간 모든 요청이 동시에 DB로 가는 현상

해결: Lock 사용해 한 요청만 DB 접근하도록 제어(캐시 스탬피드,Cache Stampede) 

캐시와 DB 간 데이터 불일치 발생 가능

해결: 중요 데이터는 TTL 짧게 설정, 수정 시 캐시도 동시에 삭제하거나 업데이트

### ⛳️ 캐시 계층(Cache Layer) 설계 전략

**📍 1단계 캐시: 인메모리 캐시 (L1)**

- 서버 내부에 Python 딕셔너리, LRUCache, FastAPI `cachetools`, Flask-Caching 등
- 초고속 응답 (마이크로초)

**📍 2단계 캐시: 외부 캐시 서버 (L2)**

- Redis / Memcached → 여러 서버에서 공유 가능
- TTL, eviction, persistence 기능 있음

**📍 3단계: DB 쿼리**

- 캐시 미스(Cache Miss) 발생 시 DB로 조회
---
## 함께 딥다이브하며 추가한 내용
### 🔍 1. **일반적인 DB 캐시 저장 위치**

| 캐시 종류 | 저장 위치 | 설명 |
| --- | --- | --- |
| **Buffer Pool / Shared Buffer** | **RAM** (메인 메모리) | 데이터 페이지를 디스크에서 읽어올 때 RAM에 보관 |
| **Query Cache (결과 캐시)** | RAM | 쿼리 결과 자체를 메모리에 저장 |
| **Disk Cache / OS Page Cache** | 운영체제의 메모리 영역 | DB 바깥에서 OS가 디스크 블록 캐싱 |
| **Temporary Tables / Spill Files** | 디스크 (Temp 디렉토리) | 메모리가 부족할 경우 디스크로 스필됨 |
| **Redis 등 외부 캐시** | 별도 서버 또는 RAM | DB 앞단에 위치한 고속 캐시 서버 |

---

### 🛠️ 2. DBMS별 캐시 위치 예시

#### ✅ MySQL (InnoDB)

- **Buffer Pool (RAM)**
    
    `/etc/my.cnf` 또는 `/etc/mysql/my.cnf` 에서 확인 가능:
    
    ```
    ini
    복사편집
    innodb_buffer_pool_size = 2G
    
    ```
    
    이만큼의 메모리를 DB가 **RAM에 예약**하여, 자주 쓰는 데이터를 캐싱합니다.
    
- **Query Cache (이전 버전)**
    
    오래된 버전에서는 쿼리 결과를 RAM에 저장하던 cache도 있었지만, 지금은 deprecated 됐어요.
    

---

#### ✅ PostgreSQL

- **Shared Buffers (RAM)**
    
    설정 위치:
    
    ```
    conf
    복사편집
    shared_buffers = 128MB
    
    ```
    
    → PostgreSQL은 여기에 자주 쓰는 데이터 블록을 올려놓고 사용
    
- **OS Page Cache도 활용**
    
    PostgreSQL은 실제 데이터를 자주 OS의 디스크 캐시를 통해 받습니다 (Double Cache 구조)
    

---

#### ✅ MongoDB (WiredTiger)

- **Cache Size (RAM)**
    
    WiredTiger는 기본적으로 전체 시스템 RAM의 **50% 정도를 캐시**로 사용
    
    ```bash
    bash
    복사편집
    storage.wiredTiger.engineConfig.cacheSizeGB
    
    ```
    
- **File Mapping**
    
    MongoDB는 **Memory-Mapped File**을 사용해, 디스크 파일을 직접 메모리에 매핑하여 사용하기도 해요 (OS 페이지 캐시를 적극 활용).
    

---

#### ✅ Redis (외부 인메모리 캐시)

- 모든 데이터가 **RAM에만 저장됨**
- 필요에 따라 **디스크로 Snapshot(RDB)** 또는 **Append-Only File(AOF)** 저장 가능
- 디폴트는 `/var/lib/redis`, 설정은 `/etc/redis/redis.conf`

---

#### 🧠 정리하면…

> 대부분의 DB는 캐시를 RAM에 올려서 운영하고, 설정 파일에서 그 크기나 동작 방식을 조정합니다.
> 
> 
> 메모리가 부족하면 일부는 디스크의 임시 공간(Temp Space)으로 넘어가기도 합니다.
> 

### 오늘의 도전 과제와 해결 방법
- 딥다이브 복습
- 개인 프로젝트
- 알고리즘 & 빅분기 기출 풀이

### 오늘의 회고
- 비교를 위해 healthy image를 증강하여 학습을 시키고 있는데, 과적합이 보다 잘 일어나는 것 같다는 생각이 들어 적절한 학습률을 찾고 있습니다.
- 다른 분들의 코드를 보면서 또 배워가고 제 코드에 적용시키고 있습니다. (역시 혼자 하는 것보다 더 깊고 넓게 알아갈 수 있는 것에 감사함을 느낍니다.) 
- 딥디이브하며 함께 배운 내용을 추가적으로 정리해봐야겠습니다.

### 참고 내용

[캐싱 전략 관련 블로그 참고] (https://loosie.tistory.com/800#Cache_%EA%B5%AC%EC%A1%B0_%EB%B0%8F_%EC%A0%84%EB%9E%B5)
[클러스터링&리플리케이션] (https://c-yhhhhh.tistory.com/147)